# Auto-generated by CodegenAgent (refined by hand)
from __future__ import annotations

import os
from typing import Any, Dict, Optional

from core.agents_base import Agent, AgentResult
from core.models import EmotionalState, EmotionDelta, ConversationContext
from core.memory import MemoryEngine
from core.llm_provider import LLMProvider

try:
    from pypdf import PdfReader
except ImportError:  # se la libreria non è installata, gestiamo il caso a runtime
    PdfReader = None


class PdfSummaryAgent(Agent):
    """
    Agente per l'estrazione e la sommarizzazione di testo da file PDF.
    - Se riceve un `pdf_path` in input_payload, prova a leggere il PDF.
    - Altrimenti, riassume il testo contenuto nel messaggio utente.

    Nota: richiede `pypdf` installato:
        pip install pypdf
    """

    name = "custom_agent_8052c722"
    description = "Agente per l'estrazione e la sommarizzazione di testo da file PDF"

    # Prompt orientato al RIASSUNTO, non all'accesso file (che fa Python)
    SYSTEM_PROMPT = """Sei un assistente che riceve del testo già estratto da un file PDF.
Il tuo compito è:
1) Riassumere il contenuto in modo chiaro e sintetico.
2) Evidenziare i punti chiave.
Rispondi in modo ordinato e leggibile per un essere umano.
"""

    def _run_impl(
        self,
        input_payload: Dict[str, Any],
        context: ConversationContext,
        memory: MemoryEngine,  # noqa: ARG002
        llm: LLMProvider,
        emotional_state: EmotionalState,  # noqa: ARG002
    ) -> AgentResult:
        # 1) Cerchiamo un pdf_path esplicito nell'input_payload
        pdf_path: Optional[str] = input_payload.get("pdf_path")

        if pdf_path:
            text_or_error, ok = self._extract_text_from_pdf(pdf_path)
            if not ok:
                # Errore nell'estrazione: restituisco il messaggio all'utente
                output = {
                    "user_visible_message": text_or_error,
                    "stop_for_user_input": False,
                }
                delta = EmotionDelta(frustration=0.02, confidence=-0.01)
                return AgentResult(output_payload=output, emotion_delta=delta)

            extracted_text = text_or_error
            user_text_for_summary = extracted_text
        else:
            # Nessun pdf_path: fallback → riassumi il testo del messaggio utente
            user_text_for_summary = (
                input_payload.get("user_message")
                or (context.messages[-1].content if context.messages else "")
            )

            if not user_text_for_summary:
                msg = (
                    "Non è stato fornito alcun `pdf_path` in input_payload e "
                    "non trovo testo da riassumere nel contesto."
                )
                output = {
                    "user_visible_message": msg,
                    "stop_for_user_input": False,
                }
                delta = EmotionDelta(frustration=0.01, confidence=-0.01)
                return AgentResult(output_payload=output, emotion_delta=delta)

        # 2) Se abbiamo il testo (estratto o fornito), chiediamo all'LLM il riassunto
        from core.models import Message, MessageRole  # import locale per evitare cicli

        messages = [
            Message(role=MessageRole.USER, content=user_text_for_summary),
        ]
        llm_output = llm.generate(
            system_prompt=self.SYSTEM_PROMPT,
            messages=messages,
            max_tokens=512,
        )

        output_text = llm_output

        # 3) Costruiamo la risposta visibile all'utente
        output = {
            "user_visible_message": output_text,
            "stop_for_user_input": False,
        }
        delta = EmotionDelta()
        return AgentResult(output_payload=output, emotion_delta=delta)

    # --------------------------------------------------------------
    #  Helper: estrazione testo PDF
    # --------------------------------------------------------------
    def _extract_text_from_pdf(self, pdf_path: str, max_pages: int = 20) -> tuple[str, bool]:
        """
        Ritorna (testo, True) se ok, oppure (messaggio_errore, False) in caso di problemi.
        """
        if PdfReader is None:
            return (
                "Per leggere i PDF è necessario installare la libreria `pypdf` "
                "(esegui: pip install pypdf).",
                False,
            )

        if not os.path.exists(pdf_path):
            return f"Il file PDF specificato non esiste: {pdf_path}", False

        try:
            reader = PdfReader(pdf_path)
        except Exception as exc:  # noqa: BLE001
            return f"Errore nell'aprire il PDF '{pdf_path}': {exc}", False

        texts: list[str] = []
        try:
            pages = list(reader.pages)
            for i, page in enumerate(pages[:max_pages]):
                page_text = page.extract_text() or ""
                texts.append(page_text)
        except Exception as exc:  # noqa: BLE001
            return f"Errore durante l'estrazione del testo dal PDF: {exc}", False

        full_text = "\n\n".join(texts).strip()
        if not full_text:
            return (
                "Sono riuscito ad aprire il PDF, ma non ho estratto alcun testo. "
                "Potrebbe trattarsi di un PDF basato su immagini (serve OCR).",
                False,
            )

        return full_text, True
